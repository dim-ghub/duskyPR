#!/usr/bin/env bash
# ==============================================================================
# Hyprland Keybind Manager - System Architect Edition
# ==============================================================================
#
# ARCHITECTURE & SAFETY PROTOCOLS:
# 1. Zero-Subprocess Parsing: Uses Bash mapfile and native ERE regex.
# 2. Intent & Comment Respect: Regex intentionally matches commented-out binds. 
#    If a user comments out a bind to disable it, the script respects that 
#    intent and will NOT aggressively re-inject it.
# 3. Atomic Write-Sync-Move: Guarantees zero file corruption.
# 4. Strict Error Handling: Bypasses Bash arithmetic evaluation traps and 
#    prevents compound command exit-code masking.
# 5. Cascading Signal Traps: Ensures deterministic temp file cleanup even 
#    under SIGINT/SIGTERM without allowing script continuation.
#
# ==============================================================================
# ==============================================================================
# HOW TO ADD NEW KEYBINDS (INSTRUCTION MANUAL)
# ==============================================================================
#
# This script uses an intelligent, intent-based injection matrix. Instead of 
# blindly checking if a specific key combination (like `$mainMod, E`) exists, 
# it searches for the *execution payload*. 
#
# WHY? If a user changes their File Manager bind from 'E' to 'F', but keeps 
# the action 'exec, uwsm-app $fileManager', this script recognizes the action 
# is still bound and will NOT overwrite or duplicate it. 
#
# ------------------------------------------------------------------------------
# THE FORMAT
# ------------------------------------------------------------------------------
# Every new keybind must be added as a single string inside the INJECTIONS 
# array, separated by the pipe delimiter '|'.
#
# Syntax: 'Search_Regex | Header_Comment | Bind_String'
#
# --- FIELD 1: Search_Regex (Bash Extended Regular Expression) ---
# This is the pattern used to scan the file. 
# * It is evaluated purely in-memory.
# * You MUST escape dollar signs (`\$`) so Bash doesn't evaluate them as variables 
#   inside the regex engine.
# * Use `.*` to allow for arbitrary spacing or command flags.
# * IMPORTANT: The regex intentionally matches commented-out lines (e.g., 
#   `# bind = ...`). If a user comments out a bind to disable it, we respect 
#   their intent and do not force-reinject it.
# * ADVANCED: If your target command is a subset of another (e.g., `$terminal` 
#   vs `$terminal -e nvim`), anchor the end of your regex with: 
#   `([[:space:]]*(#.*)?)$` 
#   This ensures it only matches the standalone command, ignoring trailing flags.
#
# --- FIELD 2: Header_Comment ---
# The exact comment string injected one line above the keybind. This keeps the 
# generated config clean and clearly marks auto-generated sections.
# Example: '# Auto-generated by My Custom Switcher'
#
# --- FIELD 3: Bind_String ---
# The actual Hyprland configuration string to inject if the regex fails to find 
# an existing match. Do NOT escape dollar signs here; you want them written 
# literally to the file.
#
# ------------------------------------------------------------------------------
# STEP-BY-STEP EXAMPLE: Adding a System Monitor (btop)
# ------------------------------------------------------------------------------
# Let's say we want to bind: 
# bindd = $mainMod, Escape, Launch Monitor, exec, uwsm-app -- $terminal -e btop
#
# 1. Regex: We want to search for 'exec, uwsm-app -- $terminal -e btop'.
#    Regex string: 'exec,.*\$terminal -e btop'
# 2. Header: '# Auto-generated by Monitor Switcher'
# 3. Bind:   'bindd = $mainMod, Escape, Launch Monitor, exec, uwsm-app -- $terminal -e btop'
#
# Combined Matrix Entry:
# 'exec,.*\$terminal -e btop|# Auto-generated by Monitor Switcher|bindd = $mainMod, Escape, Launch Monitor, exec, uwsm-app -- $terminal -e btop'
# ==============================================================================
#
set -euo pipefail

# --- Configuration ---
readonly TARGET_FILE="${HOME}/.config/hypr/edit_here/source/keybinds.conf"
readonly DELIM='|'

# --- ANSI Constants ---
readonly C_RESET=$'\033[0m'
readonly C_CYAN=$'\033[1;36m'
readonly C_GREEN=$'\033[1;32m'
readonly C_RED=$'\033[1;31m'

log_info()    { printf '%s[INFO]%s %s\n' "$C_CYAN" "$C_RESET" "$1"; }
log_success() { printf '%s[SUCCESS]%s %s\n' "$C_GREEN" "$C_RESET" "$1"; }
log_err()     { printf '%s[ERROR]%s %s\n' "$C_RED" "$C_RESET" "$1" >&2; }

# ------------------------------------------------------------------------------
# INJECTION MATRIX
# Format: "Search_Regex | Header_Comment | Bind_String"
# ------------------------------------------------------------------------------
declare -a INJECTIONS=(
    'exec,.*\$fileManager|# Auto-generated by FM Switcher|bindd = $mainMod, E, File Manager, exec, uwsm-app $fileManager'
    'exec,.*\$browser|# Auto-generated by Browser Switcher|bindd = $mainMod, W, Launch Browser, exec, uwsm-app -- $browser'
    'exec,.*\$textEditor|# Auto-generated by Text Editor Switcher|bindd = $mainMod, R, Open Text Editor, exec, uwsm-app -- $terminal --class nvim -e $textEditor'
    'exec,.*\$terminal([[:space:]]*(#.*)?)$|# Auto-generated by Terminal Switcher|bindd = $mainMod, Q, Launch Terminal, exec, uwsm-app -- $terminal'
)

# ------------------------------------------------------------------------------
# CORE LOGIC
# ------------------------------------------------------------------------------

main() {
    local target_dir="${TARGET_FILE%/*}"
    [[ -d "$target_dir" ]] || mkdir -p "$target_dir"
    [[ -f "$TARGET_FILE" ]] || touch "$TARGET_FILE"

    # 1. Load entire file into memory instantly
    local lines=()
    mapfile -t lines < "$TARGET_FILE"

    # Pure Bash in-memory evaluation
    pattern_exists() {
        local pattern="$1"
        local line
        for line in "${lines[@]}"; do
            if [[ "$line" =~ $pattern ]]; then
                return 0
            fi
        done
        return 1
    }

    local output_buffer=()
    local additions=0
    local regex header bind item

    # 2. Evaluate Matrix
    for item in "${INJECTIONS[@]}"; do
        IFS="$DELIM" read -r regex header bind <<< "$item"
        
        if ! pattern_exists "$regex"; then
            # Inject a blank line separator if appending to existing content
            if (( ${#lines[@]} > 0 || additions > 0 )); then
                output_buffer+=("")
            fi
            output_buffer+=("$header" "$bind")
            # Pre-increment prevents evaluation to 0, avoiding set -e termination
            ((++additions))
        fi
    done

    # 3. Atomic Write Execution
    if (( additions > 0 )); then
        local tmp_file=""
        
        # Proper Signal Cascading: Signal traps strictly exit, triggering the EXIT trap.
        trap '[[ -n "${tmp_file:-}" && -f "$tmp_file" ]] && rm -f "$tmp_file"' EXIT
        trap 'exit 129' HUP
        trap 'exit 130' INT
        trap 'exit 143' TERM
        
        tmp_file=$(mktemp "${TARGET_FILE}.tmp.XXXXXXXXXX") || {
            log_err "Failed to create temporary file."
            exit 1
        }

        # Match original file permissions (mktemp uses strict 0600)
        chmod --reference="$TARGET_FILE" "$tmp_file" 2>/dev/null || chmod 0644 "$tmp_file"

        # Pure Bash I/O: Chained with && to prevent exit-code masking inside the brace group
        if ! {
            { (( ${#lines[@]} == 0 )) || printf "%s\n" "${lines[@]}"; } && \
            printf "%s\n" "${output_buffer[@]}"
        } > "$tmp_file"; then
            log_err "I/O failure during in-memory buffer flush."
            exit 1
        fi

        # Flush buffer to physical disk, then atomically replace original file
        if ! { sync "$tmp_file" && mv -f "$tmp_file" "$TARGET_FILE"; }; then
            log_err "Atomic write failed during physical sync or mv operation."
            exit 1
        fi

        log_success "Injected $additions missing keybind(s) into ${TARGET_FILE}"
    else
        log_info "All configured bindings exist. Integrity verified."
    fi
}

main "$@"
